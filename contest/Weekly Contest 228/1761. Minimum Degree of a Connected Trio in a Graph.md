# 1761. Minimum Degree of a Connected Trio in a Graph

> You are given an undirected graph. You are given an integer `n` which is the number of nodes in the graph and an array `edges`, where each `edges[i] = [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`.
>
> A **connected trio** is a set of **three** nodes where there is an edge between **every** pair of them.
>
> The **degree of a connected trio** is the number of edges where one endpoint is in the trio, and the other is not.
>
> Return *the **minimum** degree of a connected trio in the graph, or* `-1` *if the graph has no connected trios.*
>
>  
>
> **Example 1:**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/26/trios1.png)
>
> ```
> Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]]
> Output: 3
> Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above.
> ```
>
> **Example 2:**
>
> ![img](https://assets.leetcode.com/uploads/2021/01/26/trios2.png)
>
> ```
> Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]]
> Output: 0
> Explanation: There are exactly three trios:
> 1) [1,4,3] with degree 0.
> 2) [2,5,6] with degree 2.
> 3) [5,6,7] with degree 2.
> ```
>
>  
>
> **Constraints:**
>
> - `2 <= n <= 400`
> - `edges[i].length == 2`
> - `1 <= edges.length <= n * (n-1) / 2`
> - `1 <= ui, vi <= n`
> - `ui != vi`
> - There are no repeated edges.

因为 n 的取值范围不大，直接暴力，先将输入的图存入邻接矩阵，然后遍历寻找三元环。中间优化技巧：当顶点 i 与顶点 j 之间没有连边时直接continue；事先将各个顶点的度数计算并保存；遍历时避免重复计算（j 从 i+1 开始，k 从 j+1 开始）。

代码如下：

```python
class Solution:
    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:
        matrix = [[0 for i in range(n)] for j in range(n)]
        for edge in edges:
            matrix[edge[0]-1][edge[1]-1] = 1
            matrix[edge[1]-1][edge[0]-1] = 1
        degrees = [sum(matrix[x]) for x in range(n)]
        res = 3 * len(matrix)
        has_trio = False
        for i in range(n):
            for j in range(i+1, n):
                if matrix[i][j] == 0:
                    continue
                for k in range(j+1, n):
                    if matrix[j][k] == 1 and matrix[k][i] == 1:
                        has_trio = True
                        res = min(res, degrees[i] + degrees[j] + degrees[k] - 6)
        if not has_trio:
            return -1
        return res
```

