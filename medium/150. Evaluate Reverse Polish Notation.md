# 150. Evaluate Reverse Polish Notation

> Evaluate the value of an arithmetic expression in [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).
>
> Valid operators are `+`, `-`, `*`, `/`. Each operand may be an integer or another expression.
>
> **Note:**
>
> - Division between two integers should truncate toward zero.
> - The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
>
> **Example 1:**
>
> ```
> Input: ["2", "1", "+", "3", "*"]
> Output: 9
> Explanation: ((2 + 1) * 3) = 9
> ```
>
> **Example 2:**
>
> ```
> Input: ["4", "13", "5", "/", "+"]
> Output: 6
> Explanation: (4 + (13 / 5)) = 6
> ```
>
> **Example 3:**
>
> ```
> Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
> Output: 22
> Explanation: 
>   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
> = ((10 * (6 / (12 * -11))) + 17) + 5
> = ((10 * (6 / -132)) + 17) + 5
> = ((10 * 0) + 17) + 5
> = (0 + 17) + 5
> = 17 + 5
> = 22
> ```

利用栈。

代码如下：

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        def operate(num1, num2, token):
            if token == '+':
                return num1 + num2
            elif token == '-':
                return num2 - num1
            elif token == '*':
                return num1 * num2
            else:
                sign = 1
                if num2 < 0:
                    num2 = -num2
                    sign *= -1
                if num1 < 0:
                    num1 = -num1
                    sign *= -1
                return sign * (num2 // num1)
            
        s = []
        for token in tokens:
            #print (s)
            if token in {'+', '-', '*', '/'}:
                num1 = int(s.pop())
                num2 = int(s.pop())
                s.append(operate(num1, num2, token))
            else:
                s.append(token)
        return s.pop()
```

